## はじめに

すべてのビジネスシステムはCRUDから切り離すことはできません。

CRMシステム、内部管理システム、承認ワークフロー、管理ダッシュボードなどの開発経験があれば、この感覚に覚えがあるでしょう。毎回、ゼロから始めて、CRUDのセット全体を再度実装する必要があります。

エンタープライズの内部システムでは：異なる部門、異なるプロジェクト、異なる段階でそれぞれが高度に類似したシステムを維持していますが、互いに断片化されています。システムが増えれば増えるほど、重複するCRUDが蓄積され、それに応じて保守コストも積み重なります。

外注や統合のシナリオでは、この問題は特に顕著です。プロジェクトは似ているように見えますが、真に再利用することはできません。クライアントは変更は小さいと感じる一方で、提供側は2倍以上の保守コストを負担する必要があります。新しいクライアントごとに、ほぼ常に新しいCRUDライフサイクルを意味します。

今日の記事では、さまざまなアプローチに沿って、開発者が効果的に反復的なCRUDを減らすことができるオープンソースツールを紹介します。

**おすすめ記事：GitHubでスター数が最も多い8つのCRUDオープンソースプロジェクト**

## 反復的なCRUDを減らすアプローチ

反復的なCRUDを減らすには、異なるレベルからアプローチできます。

**最初のアプローチ：CRUDをより早く書く**

これが最も一般的なアプローチです。スキャフォールディング、コード生成、テンプレートプロジェクトを使用して、基本的な作成、読み取り、更新、削除機能を迅速に構築し、ボイラープレートコードを手書きする時間を削減します。

**2番目のアプローチ：バックエンドと管理インターフェースの重複を減らす**

汎用的なリスト、フォーム、権限、基本設定インターフェースなど、共通のバックエンド機能を抽出して再利用します。このアプローチの核心は、インターフェースと管理機能の反復的な開発を減らすことにありますが、データ構造とビジネスルールは依然としてコードによって定義されます。各プロジェクトには依然として独自のモデルセットがありますが、バックエンドの実装方法はより統一されています。

**3番目のアプローチ：プロジェクト間の差異のコストを削減する**

反復が要件構造レベルで現れ始めると、単にバックエンドコードを再利用するだけでは不十分になります。そこで一部のソリューションは、フィールド、関係、権限、ワークフローをコードから抽出し、設定またはデータモデルで記述することを選択します。このモードでは、プロジェクト間の違いは、コード構造の違いではなく、モデル設定の違いに反映されます。

**4番目のアプローチ：類似したシステムを繰り返し提供することを避ける**

データモデル、権限、拡張メカニズムはすべて、同じ核心構造を中心に展開します。新しい要件はシステムの再提供というよりは、システムの拡張のようになります。このアプローチはコストは高いですが、最も根本的な問題に対処します。なぜ類似したシステムは常にゼロから始める必要があるのでしょうか？

## ツールの推奨

以下では、4つのアプローチそれぞれから、対応する問題を解決できる製品とツールを推奨します。プロジェクトの実際の状況に基づいて、最適なツールを選択できます。4番目のアプローチから始めましょう。

## CRUDを長期的なシステム能力として扱う

### NocoBase

ウェブサイト：https://www.nocobase.com/

GitHub：https://github.com/nocobase/nocobase

GitHubスター数：21k

NocoBaseは、エンタープライズのCRUD能力をワンタイム開発からシステム能力に変えることができるオープンソースのノーコード/ローコード開発プラットフォームです。データモデル駆動のアプローチを通じて、ビジネス担当者と技術担当者が協力して複雑なビジネスシステムを構築でき、毎回ゼロからCRUDコードを書く必要がありません。

**核心能力：**

* **データモデル駆動のCRUD**：ビジュアルインターフェースを通じてデータテーブル、フィールド、関係を定義すると、システムが自動的に完全な作成、読み取り、更新、削除インターフェースとAPIを生成し、コードを書く必要がありません。NocoBaseはPostgreSQL、MySQL、MariaDBなどの主流データベースに直接接続でき、既存のデータを迅速に統合し、データ構造を移行 or 変換することなくビジネスシステムを構築できます。
* **柔軟なフロントエンド設定**：さまざまなフィールドタイプ、フォーム検証、動的な表示/非表示、連動ルールをサポートし、ビジネスロジックに一致したデータ入力インターフェースを設定でき、フロントエンド開発作業を削減します。
* **強力なクエリとリスト能力**：さまざまなタイプのブロックが組み込まれ、フィルタリング、ソート、ページネーション、エクスポートなどの機能をサポートし、設定を通じて複雑なデータ表示要件を実現できます。
* **きめ細かな権限制御**：ロールとユーザー権限だけでなく、フィールドレベル（誰がどのフィールドを表示/編集できるか）とデータレベル（誰がどのデータ行を操作できるか）まで制御でき、CRUDレベルでデータセキュリティを保証します。
* **拡張可能なワークフロー**：ワークフローエンジンを通じてビジネスプロセスを設定できます。たとえば、データ提出後の承認、ステータス変更、自動通知などで、CRUD操作をビジネスプロセスに統合し、孤立したデータ操作ではなくします。
* **プラグインアーキテクチャ**：複雑なCRUDロジックの場合、プラグインを通じてシステム機能を拡張でき、一度開発、何度も再利用でき、異なるプロジェクトでカスタムプラグインを共有できます。

**適用シナリオ**：長期的な保守が必要なエンタープライズ内部システム、複数の類似プロジェクト、ビジネス設定権限を非技術担当者に渡したいチーム。

### Odoo

ウェブサイト：https://www.odoo.com/

GitHub：https://github.com/odoo/odoo

GitHubスター数：48.1k

Odooは高度にモジュール化されたエンタープライズリソースプランニング（ERP）およびビジネス管理プラットフォームで、統一されたデータベースモデルとアプリケーションフレームワークを通じて、さまざまなビジネスシナリオのCRUD操作を標準化し、モジュール化します。CRMから在庫管理、会計から人事まで、すべてのモジュールは同じデータモデルと権限システムに基づいており、異なるシステム間の反復的な開発とデータの断片化を回避します。

**核心能力：**

* **統一されたCRUDフレームワーク**：すべてのOdooモジュールは同じORMフレームワークとビューシステムに基づいています。データモデルを定義すると、リストビュー、フォームビュー、検索ビューが自動的に生成され、反復的なインターフェース開発を大幅に削減します。
* **モジュール化されたビジネスロジックの再利用**：各ビジネスモジュールは独立したCRUDアプリケーションで、別々にインストールまたは組み合わせて使用できます。新しいビジネス要件を追加する際、多くの場合、モジュールをインストールまたは設定するだけで済み、再開発する必要がありません。
* **関連データの自動統合**：すべてのモジュールが同じデータベースを共有しているため、あるモジュールのCRUD操作は自動的に他のモジュールに関連付けることができます。たとえば、販売注文を作成するとき、在庫が自動的に引き落とされ、顧客情報が更新され、クロスシステム統合のCRUD開発を回避します。
* **自動化とルールエンジン**：自動化アクションとビジネスルールを通じて、データが作成、更新、削除されるときにカスタムロジックをトリガーできます。たとえば、ステータス遷移、自動フィールド計算、通知送信などで、コードを書くことなくCRUD動作を拡張できます。

**適用シナリオ**：中小企業の統合ビジネス管理、標準的なビジネスプロセスを必要とする業界、すぐに使えるソリューションを望むチーム

## CRUDをコードから設定に変える

### Directus

ウェブサイト：https://directus.io/

GitHub：https://github.com/directus/directus

GitHubスター数：33.8k

Directusは、既存のデータベースを完全なバックエンドプラットフォームとCRUDアプリケーションに変換するツールです。既存のSQLデータベースに接続し、自動的にRESTfulおよびGraphQL APIを生成すると同時に、ビジュアル管理インターフェースとデータモデル設定機能を提供し、バックエンドコードを書くことなく、任意のデータベースに完全な作成、読み取り、更新、削除能力を提供できます。

**核心能力：**

* **CRUD APIの自動生成**：データベースに接続すると、Directusは自動的にテーブル構造をスキャンし、各テーブルの標準的なCRUD API（作成、読み取り、更新、削除）を生成し、RESTfulとGraphQLの両方のクエリメソッドをサポートします。フロントエンドはバックエンド開発なしで直接呼び出すことができます。
* **ビジュアルデータモデル管理**：インターフェースを通じてテーブル構造、フィールドタイプ、関係を管理し、すべての変更はデータベースに同期され、SQL移行スクリプトを手書きする必要がありません。データモデルの変更はAPIと管理インターフェースに直接反映されます。
* **宣言的権限制御**：設定インターフェースを通じて異なるロールのCRUD権限を定義し、フィールドレベル（どのロールがどのフィールドを読み取り/編集できるか）とデータレベル（行レベル権限、動的ルールに基づいてデータをフィルタリング）まで正確に制御できます。権限設定はAPIと管理インターフェースに自動的に適用されます。
* **すぐに使える管理バックエンド**：各テーブルのリストとフォームインターフェースを自動的に生成し、検索、フィルタリング、ソート、ページネーションをサポートし、内部管理または迅速なプロトタイプとして直接使用でき、バックエンド開発時間を大幅に削減します。

**適用シナリオ**：既存のデータベースで迅速な管理バックエンド構築が必要、統一されたAPIと権限レイヤーが必要、ビジネス設定をコードから切り離したい。

### Hasura

ウェブサイト：https://hasura.io/

GitHub：https://github.com/hasura/graphql-engine

GitHubスター数：31.9k

**位置づけ**：既存のデータベースに接続すると、数秒で高性能なCRUD GraphQL APIを生成するインスタントGraphQLエンジンです。設定を通じて権限、検証、ビジネスロジックを制御し、バックエンドコードを書くことなく、任意のアプリケーションに完全なデータクエリと変更能力を提供できます。

**核心能力：**

* **数秒でGraphQL CRUD APIを生成**：データベースに接続すると、Hasuraは各テーブルのクエリ、挿入、更新、削除のGraphQL操作を自動的に生成し、すべてのCRUD操作は統一されたGraphQLエンドポイントを通じて完了し、REST APIを手書きする必要がありません。
* **強力なクエリ能力**：フィルタリング、ページネーション、ソート、集計、ネストされた関係クエリをサポートし、1つのリクエストで複数のCRUD操作を完了でき、ネットワークの往復を削減し、フロントエンドは必要なデータを柔軟に取得できます。
* **リアルタイムサブスクリプション**：データベースの変更データキャプチャ（CDC）機能に基づいて、任意のCRUD操作のリアルタイムサブスクリプションを確立でき、データが変更されると自動的にクライアントにプッシュされ、WebSocketを手動で実装する必要がありません。
* **リモートスキーマ連合**：Hasuraが生成したCRUD APIを他のGraphQLサービスと連合して統一されたAPIゲートウェイを形成でき、1つのGraphQLクエリで複数のデータソースを操作できます。
* **イベントトリガー**：データベースでCRUD操作が発生すると、Webhookをトリガーして外部サービスを呼び出し、データ変更後の通知、同期、クリーンアップなどのビジネスロジックを実装できます。

**適用シナリオ**：高性能GraphQL APIが必要なプロジェクト、データ取得ロジックを直接制御したいフロントエンドチーム、マイクロサービスアーキテクチャのBFL層。

### Supabase

ウェブサイト：https://supabase.com/

GitHub：https://github.com/supabase/supabase

GitHubスター数：95.4k

オープンソースのFirebase代替案として、SupabaseはPostgreSQLデータベース、インスタントCRUD API、認証、リアルタイムサブスクリプション、ファイル保存などの完全なバックエンド機能を提供します。データベース構造を定義するだけで、Supabaseは自動的に対応する作成、読み取り、更新、削除能力を生成し、数分で完全なフルスタックアプリケーションを起動でき、バックエンドコードを書く必要がありません。

**核心能力：**

* **CRUD APIの自動生成**：テーブルを作成すると、Supabaseは自動的にRESTful APIを生成し、すべての標準的なCRUD操作をサポートし、マルチ言語SDK（JavaScript、TypeScript、Pythonなど）を提供し、数行のコードでデータ操作を完了できます。
* **行レベルセキュリティ（RLS）**：PostgreSQLのネイティブ行レベルセキュリティポリシーに基づいて、SQLルールを通じて誰がどのデータでCRUD操作を実行できるかを定義します。権限ロジックはデータベースレイヤーで直接実行され、バイパスすることはできず、セキュリティが高いです。
* **リアルタイムデータ同期**：PostgreSQLの論理レプリケーション機能に基づいて、任意のテーブルのCRUD操作のリアルタイムサブスクリプションを確立できます。データが挿入、更新、または削除されると、自動的にすべてのサブスクライブ済みクライアントにプッシュされ、追加の開発が不要です。
* **組み込み認証**：完全なユーザー認証システム（メール、パスワード、OAuth、電話番号など）を提供し、RLSと統合されているため、ユーザーは自分のデータのみをCRUDでき、すぐに使えるマルチテナント能力があります。
* **ビジュアルテーブル管理**：オンラインテーブルエディターを提供し、テーブルの作成、フィールドの定義、関係の設定、データの挿入と変更ができ、SQLなしでデータベース構造を管理できます。

**適用シナリオ**：迅速な起動が必要なSaaS製品、バックエンド構築時間を削減したいスタートアップ、リアルタイム機能が必要なアプリケーション

## バックエンドと管理インターフェースの重複を削減する

### Appsmith

ウェブサイト：https://appsmith.com/

GitHub：https://github.com/appsmithorg/appsmith

GitHubスター数：38.8k

Appsmithは開発者がビジュアル方式で迅速にCRUDインターフェースを構築できるようにします。Retoolに似ていますが、完全にオープンソースでセルフホスト可能で、独自のサーバーにデプロイでき、データは第三者サービスを通過せず、データセキュリティ要件が高いシナリオに非常に適しています。

**核心能力：**

* **ビジュアルCRUDアプリの構築**：テーブル、フォーム、ボタン、チャートなどのコンポーネントを提供し、ドラッグ＆ドロップで完全なデータ管理インターフェースを構築できます。テーブルはインライン編集、バッチ操作をサポートし、フォームはマルチステップ送信、ファイルアップロードなどの複雑なシナリオをサポートします。
* **複数のデータソースに接続**：SQL/NoSQLデータベース、REST API、GraphQL、SaaSサービスなど複数のデータソースに接続でき、1つのアプリケーションで複数のデータソースのCRUD操作を統合できます。
* **JSコード強化**：各コンポーネントのアクションに対してJavaScriptコードを書くことができ、送信前の検証、成功後のリダイレクト、エラー処理など、さまざまなCRUDビジネスロジックを柔軟に処理できます。
* **レスポンシブレイアウトとテーマカスタマイズ**：レスポンシブデザインをサポートし、インターフェースは異なる画面サイズに適応できます。テーマエディターを提供し、ブランドカラー、フォント、間隔などをカスタマイズでき、CRUDインターフェースを企業VI規格に準拠させることができます。
* **APIサポート**：構築したアプリケーションはREST APIとして公開でき、手動操作のCRUDインターフェースを呼び出し可能なサービスに変換できます。

**適用シナリオ**：カスタマイズされたバックエンドを構築する必要があるチーム、コードを制御したいオープンソース優先プロジェクト、頻繁な内部ツールの調整が必要なビジネス、データセキュリティ要件が高い業界

### AdminJS

ウェブサイト：https://adminjs.co/

GitHub：https://github.com/softwarebrothers/adminjs

GitHubスター数：8.9k

**位置づけ**：Node.jsベースの自動管理バックエンド生成ツールで、既存のバックエンドアプリケーションに接続し、データモデルに基づいて完全なCRUD管理インターフェースを自動的に生成できます。データモデル定義（TypeORMエンティティ、Prismaスキーマなど）を提供するだけで、AdminJSはリストページ、フォームページ、フィルターなどすべての標準機能を自動的に生成します。

**核心能力：**

* **すぐに使える完全なCRUD機能**：自動生成されたインターフェースにはリスト表示、検索、フィルタリング、ソート、ページネーション、作成フォーム、編集フォーム、削除確認などの機能が含まれ、フロントエンド開発なしですぐに使用できます。
* **柔軟なインターフェースカスタマイズ**：設定を通じて各モデルの表示フィールド、フォームレイアウト、検証ルール、アクションボタンをカスタマイズでき、カスタムコンポーネントを書いて特別なCRUDインタラクションを実装することもできます。
* **権限制御統合**：ロールベースのアクセス制御をサポートし、異なるユーザーがどのモデルでCRUD権限を持つかを制限でき、設定で関数を通じて権限ロジックを動的に決定することもできます。
* **容易な統合**：数行のコードでAdminJSを既存のExpress、Hapi、NestJSアプリケーションに統合でき、既存のコード構造を変更せず、管理バックエンドの迅速なソリューションとして機能できます。

**適用シナリオ**：既存のNode.jsバックエンドがあるプロジェクト、管理インターフェースの迅速な追加が必要なシナリオ、ゼロから開発するのではなく自動生成を望むチーム

## CRUDをより早く書く

### Rails Generators

ウェブサイト：https://rubyonrails.org/

GitHub：https://github.com/rails/rails

GitHubスター数：58k

**位置づけ**：Ruby on Railsフレームワークに組み込まれているコード生成ツールで、設定より規約の哲学とスキャフォールディングメカニズムを通じて、完全なCRUDコードを迅速に生成できます。データモデルを定義するだけで、1つのコマンドでモデルクラス、データベース移行、コントローラー、ビュー、ルート、テストなどすべての必要なコードを生成し、反復的なボイラープレートコードの作成を大幅に削減します。

**核心能力：**

* **スキャフォールディング**：1つのコマンド（例：`rails generate scaffold Post title:string body:text`）で、モデル、移行ファイル、コントローラー（7つの標準アクション：index、show、new、edit、create、update、destroyを含む）、ビューファイル（リスト、詳細、作成、編集フォーム）、ルート設定を含む完全なCRUD機能を生成します。
* **リソースルート**：`resources :posts`を宣言すると、すべての標準的なCRUDルート（GET /posts、GET /posts/:id、POST /posts、PATCH/PUT /posts/:id、DELETE /posts/:id）が自動的に生成され、個別に定義する必要がありません。
* **ストロングパラメータ**：パラメータホワイトリストメカニズムを通じてフォーム送信データを自動的にフィルタリングし、許可されたフィールドのみがモデルに割り当てられ、一括割り当て脆弱性を防止しながら、手動パラメータ処理コードを削減します。
* **テストフレームワーク統合**：CRUDコードを生成するとき、対応するテストファイル（単体テストと機能テスト）も生成し、基本的なCRUD操作テストケースを含み、テスト駆動開発を奨励します。

**適用シナリオ**：Ruby技術スタックを使用するチーム、迅速な起動が必要なCRUDプロジェクト、開発体験とコード規格を重視するチーム。

### JHipster

ウェブサイト：https://www.jhipster.tech/

GitHub：https://github.com/jhipster/generator-jhipster

GitHubスター数：22.3k

**位置づけ**：Java / Spring Bootエコシステム向けに構築されたアプリケーションスキャフォールディングで、エンティティ、CRUD API、フロントエンドインターフェース、セキュリティ設定など完全な機能を含むエンタープライズレベルのアプリケーションを迅速に生成できます。業界標準に準拠し、保守性の高いコードを生成し、Java開発者を面倒な設定とボイラープレートコードから解放してビジネスロジックに集中させます。

**核心能力：**

* **エンティティ駆動のCRUD生成**：エンティティとフィールドを定義することで、JHipsterは自動的にバックエンドのJPAエンティティクラス、Repository、Service、REST Controller（CRUDエンドポイントを含む）、およびフロントエンドのリストページ、フォームページ、詳細ページを生成します。
* **完全な技術スタック統合**：バックエンドはSpring Boot、Spring Security、Spring Data JPAを使用し、フロントエンドはAngular、React、Vueの3つの選択肢をサポートし、生成されたコードにはデータベース接続、トランザクション管理、例外処理、ログ記録などすべてのエンタープライズレベルの設定が含まれます。
* **権限とセキュリティ**：Spring Securityを統合し、生成されたCRUDエンドポイントはデフォルトで認証が必要です。アノテーションでロール権限（@PreAuthorize）を設定でき、フロントエンドはログイン、ログアウト、権限チェックを自動的に処理します。
* **マイクロサービスサポート**：モノリシックアプリケーションまたはマイクロサービスアーキテクチャを生成するかを選択できます。マイクロサービスモードにはサービス登録、設定センター、ゲートウェイなどのコンポーネントが含まれ、生成されたCRUDサービスはクラスターに直接登録できます。

**適用シナリオ**：Javaエンタープライズアプリケーション開発、標準化されたプロジェクト構造が必要なチーム、フロントエンドとバックエンドの統合生成を望むプロジェクト。

### Yeoman

ウェブサイト：https://yeoman.io/

GitHub：https://github.com/yeoman/yeoman

GitHubスター数：10.1k

**位置づけ**：汎用プロジェクトスキャフォールディングツールで、Generator（ジェネレーター）エコシステムを通じて、さまざまな技術スタックとプロジェクトタイプのCRUDプロジェクトを迅速に初期化する能力を提供します。コード自体は生成しませんが、Generatorを実行するフレームワークを提供し、開発者はコミュニティGeneratorを作成または再利用して、プロジェクトの基盤構造を迅速に構築できます。

**核心能力：**

* **対話型プロジェクト初期化**：Generatorを実行するとき、Q&A形式でプロジェクト設定（技術スタック、パッケージマネージャー、ビルドツール、認証が必要か、データベースタイプなど）を収集し、選択に基づいてカスタマイズされたプロジェクト構造を生成します。
* **豊富なGeneratorエコシステム**：コミュニティは数千のGeneratorを提供し、さまざまなCRUDアプリケーションシナリオをカバーしています。たとえば、generator-node-express-mongo（Node + Express + MongoDBのCRUDバックエンドを生成）、generator-gulp-webapp（フロントエンドアプリケーションを生成）、generator-jhipster（JHipsterもYeomanベース）など。
* **カスタムチームGenerator**：一般的に使用されるCRUDプロジェクト構造、コード規格、依存関係バージョンをカスタムGeneratorとして固定化できます。新しいプロジェクトは1つのコマンドで統一された構造のコードを生成でき、異なる開発者の「独自のやり方」を回避できます。
* **モジュール化と組み合わせ**：Generatorは他のGeneratorを継承および組み合わせることができます。たとえば、ビジネスシステムのGeneratorは基本のCRUD Generatorを再利用し、ビジネス固有の設定とコードを追加できます。
* **ビルドツールとの統合**：生成されたプロジェクト通常、完全なビルド設定（Webpack、Vite、Gradleなど）が含まれ、npm install後すぐに実行でき、追加の設定は不要です。
* **更新とバージョン管理**：Generator自体を独立してアップグレードできます。チームは最新バージョンのGeneratorを使用して新しいプロジェクトを生成でき、古いプロジェクトを手動でコピーおよび変更する必要がありません。

**適用シナリオ**：カスタムプロジェクトスキャフォールディングが必要なチーム、複数の技術スタックが共存する組織、チームプロジェクト構造を統一したいチーム

## 最後に

反復的なCRUDを減らすことは、本質的に異なるレベルで再利用能力を確立することです。

スキャフォールディング、コード生成から設定プラットフォーム、システムアーキテクチャまで、各アプローチには解決すべき問題があり、境界もあります。

したがって、ツールを選択する前に、真剣に3つのことを考える価値があります。

* この問題は、次のプロジェクトで再び発生するでしょうか？
* 今少し時間をかけるか、後で何度も書き直すか？
* システムが10のテーブルから100のテーブルになったとき、このツールはまだ対応できますか？

ツールは単なる出発点です。要件の変更によって簡単に覆されないシステム能力を確立できるかどうかが、長期的な効率の分水嶺です。

この記事が役立つと思ったら、より多くの友達と共有してください！

**免責事項**：この記事はAIの支援を得て執筆され、実際の人間が視点、データ、画像を追加しています。
